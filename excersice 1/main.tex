\documentclass[a4paper]{article}

\renewcommand{\labelenumi}{(\alph{enumi})}

\usepackage{listings}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{fancyhdr}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\pagestyle{fancy}

\lhead{Chalmers - EDA282}
\chead{Excercise 1}
\rhead{Dan Larsson}
\lfoot{November 2014}


\begin{document}
\textcolor{red}{\huge Changed stuff marked in red.}
\section*{Q1}
\begin{enumerate}
\item % a
The goal of the algorithm in Listing 1 is to group n points into m clusters. This is done by invoking the function \texttt{kernel} until its return value \texttt{delta} is equal to 0. In \texttt{kernel} all points are itterated over to find which one of the m clusters supplied in \texttt{clusters} is closest. To find the closest cluster all clusters are itterated over in \texttt{find\_nearest\_point} and the Euclidean distance is calulated in \texttt{euclid\_dist\_2}. When all clusters have been itterated over the index of the cloest one is returned to \texttt{kernel}. This index is used to check if the point already belongs to this cluster, if not delta is increased to indicate that a point have changed cluster. To calulate the center of each cluster an average of the cooridnates for all points belonging to the cluster are calulated. 

\item % b
\label{itm:b}
One way to parallelize the \texttt{kernel} would be to simply divide all points into p parts, where p is the amount of processors. For this to work the variables \texttt{new\_centers} and \texttt{new\_centers\_len} would need to be syncronized. This can be done using the \texttt{parallel for} and \texttt{critical} directive of \texttt{OpenMP}. 

\item % c
\label{itm:c}
As mentioned in (b), there would be a need for synchronization of the variables \texttt{new\_centers} and \texttt{new\_centers\_len}. For the other global variables, \texttt{clusters} and \texttt{feature} are only read and \texttt{membership} is only accessed based on the index of each point and as the different processors have no overlapping points there will accesses to the same addresses. In listing~\ref{lst:kernelcoarse} a modified kernel with \texttt{OpenMP} directives for a coarse grained aproach is shown.

\item % d
\textcolor{red}{
A more fine grained solution than the one presented in (c) is shown in listing~\ref{lst:kernelfine} where \texttt{OpenMP}s runtime locks have been used. As explained in (c) \texttt{new\_centers} and \texttt{new\_centers\_len} need protection an now also \texttt{delta} as we no longer use the \texttt{reduction} directive. As we protext every singel address new no need $ 1 + 3 \times nclusters$ locks in total.
}


\end{enumerate}
\lstset{language=C,frame=single}
\lstinputlisting[lastline=31, caption={Modified kernel coarse grained},label={lst:kernelcoarse}]{upgC.c}
\textcolor{red}{
\lstinputlisting[firstline=32, caption={Modified kernel fine grained},label={lst:kernelfine}]{upgC.c}
}
\section*{Q2}
The request write/read sequence will be as follows: \\

\texttt{W0~W1~R0~R1~W2~W3~R2~R3~W4~W5~R4~R5~W6~W7~R6~R7} \\ \\
and the values that the 8 processors will read will be the following:\\

\begin{tabular}{ l | c c c c c c c c }

\textbf{Processor} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\textbf{Read}     & 1 & 1 & 3 & 3 & 5 & 5 & 7 & 7 \\

\end{tabular}

\section*{Q3}
\begin{enumerate}
\item % a 
\label{itm:3a}
\textcolor{red}{
The amount of cycles will be the following for MSI:
\texttt{
  \\Proc1: (Snoop + LvL2Rd + Rd) + (BusUP + Snoop + Wr) + Wr
  \\Proc2: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr
  \\Proc3: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr
  \\Proc4: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr 
}
}
\textcolor{red}{
\[(5+40+1)+(10+5+1)+1+3\times((5+20+1)+(10+5+1)+1) = 192\]
and for MESI:
\texttt{
  \\Proc1: (Snoop + LvL2Rd + Rd) + Wr + Wr
  \\Proc2: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr
  \\Proc3: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr
  \\Proc4: (Snoop + LvL1Rd + Rd) + (BusUP + Snoop + Wr) + Wr 
}
}
\textcolor{red}{
\[(5+40+1)+1+1+3\times(5+20+1+(10+5+1)+1) = 177\]
where the difference is due to the first processor going to the E state instead of the S state and thereby saves 15 cycles when it then wants to write by not needing to emit a busupgrade and or snoop the bus. I assume that the bus upgrades does not include any snoop.}

\item % b 
\textcolor{red}{
The amount of trafic that gets generated for MSI based on the sequences in (a)):
\[4\times(38B+10B) = 192B\]
and for MESI:
\[38B+3\times(38B+10B) = 182B\]
}
\end{enumerate}

\section*{Q4} % 7.2
\begin{enumerate}
\item % a
There is no need to protect the read as if the read returns the wrong value, it will be a lower value than it should and the read can simply be done again.
\item % b 
See listing~\ref{lst:q4b}.

\item % c
See listing~\ref{lst:q4c}.
\end{enumerate}

\lstset{language={[x86masm]Assembler},frame=single}
\lstinputlisting[firstline=24, lastline=36, caption={Sync. using T\&S},label={lst:q4b}]{upgASM.asm}
\textcolor{red}{
\lstinputlisting[firstline=39, lastline=44, caption={Sync. using F\&A},label={lst:q4c}]{upgASM.asm}
}
\section*{Q5} % 7.3
\begin{enumerate}
\item % a
See listing~\ref{lst:q5a}.
\setcounter{enumi}{3}
\item % d
See listing~\ref{lst:q5d}.
\item % e
See listing~\ref{lst:q5e}.
\end{enumerate}


\lstset{language={[x86masm]Assembler},frame=single}
\textcolor{red}{
\lstinputlisting[firstline=2, lastline=5, caption={F\&ADD X, Rx, a},label={lst:q5a}]{upgASM.asm}
}
\textcolor{red}{
\lstinputlisting[firstline=8, lastline=12, caption={SWAP(Rx, X)},label={lst:q5d}]{upgASM.asm}
}
\textcolor{red}{
\lstinputlisting[firstline=15, lastline=21, caption={CAS Rx, Ry, X},label={lst:q5e}]{upgASM.asm}
}

\end{document}















