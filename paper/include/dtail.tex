Cui et al. \cite{dtail} propose DTail. They evaluate two versions of DTail referenced as DTail-R and DTail-V utilizing R and V information, respectively. Even so, their main idea is that more types of  information can be incorporated and stored together with the R and V information. DTail can then choose the most efficient refresh schema depending on the current situation, i.e. workload and type of application. The R and V information, called\textit{refresh data}, is kept per row and is stored in the DRAM itself instead of in the MC which many other solutions do \cite{raidr}\cite{smartrefresh}\cite{refrint}. To counter the added latency of a slower memory (DRAM versus fast memory in the MC), Cui et al. utilizes spatial locality of the RV information and performs prefetching into a FIFO buffer. As the refresh data is kept on a row level DTail can save more refreshes than other techniques that have a lower granularity. How to actually implement the acquisition of the \textit{refresh data} is not stated, but Cui et al. proposes that a few modifications to the OS would work well, as the OS can manage the refresh data residing in DRAM.

For DTail-R, the Retention Time data $n$ consists of three bits and is interpreted in such way that the refresh period can become \(64\:ms \times 2^n, n = [0..7]\). With DTail-V, one additional bit is added to the refresh data which is used to indicate if the row is valid or not. With this structure of four bits per row, the amount of memory required is $0.006\%$ of DRAM capacity assuming a row size of \textit{8 KB}.

The number of rows refreshed when a CBR is issued is denoted by Cui et al. as a super row. When the first row in a super row is selected for refresh, DTail decides if CBR or ROR should be used for all the consecutive rows in the super row. If a large number of rows need to be refreshed then CBR is selected, otherwise ROR. To be able to use CBR, Cui et al. proposes a new refresh command that increments a rank's internal address counter, which makes it possible for the internal address counter to be synchronized with MC's address counter. When ROR is used, the row's Retention Time and Validity information is considered; if the row is valid and the time since the last refresh is $n \times 64\:ms$ a refresh is performed. 

When only DTail-R is used, Cui et al. manages to decrease the number of refreshes with as much as $87.9\%$ and thereby only have $16.7\%$ energy overhead compared to a refresh less \textit{32~GB} DRAM. With only DTail-V power consumption and performance overhead increase from $4\%$ and $3\%$ to $90\%$ and $23\%$, respectively, when going from $10\%$ to $90\%$ memory utilization compared to a refresh less \textit{32~GB} system. The power of DTail shows when DTail-R and DTail-V are used together and at $10\%$ memory utilization, a performance overhead of only $1\%$ and close to $0\%$ increase in energy consumption is achieved. When the utilization is increased to $90\%$, they increase to $2\%$ and $15\%$, respectively.

Comparing DTail-R with the somewhat similar RAIDR, Cui et al. achieves a bigger decrease in refresh operations compared to what Liu et al. does. This is due to DTail-R having a higher granularity as the refresh rate is kept per row and not per row group as in RAIDR.