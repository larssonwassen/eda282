In this approach, RAIDR by Liu et al. \cite{raidr}, all memory rows gets divided into different groups, called bins, based on the cell with the shortest retention time in the row. In the basic configuration there are two bins, one with rows that need a refresh rate of $64ms \to 128ms$ and one with rows that need to be refreshed every $128ms \to 256ms$. Rows in the first bin gets refreshed every $64ms$, rows in the second bin every $128ms$, and all remaining rows gets refreshed at the default refresh rate which is set to $256ms$. This is done using two counters, one row counter that rolls over every $64ms$, and one counter that keeps track on how many times the row counter have rolled. With this every row will get selected as refresh candidate every $64ms$, the refresh will be performed depending on which bin the row belongs to and on the second counter's value. The actual refreshes are performed by activating the row in question essentially performing a ROR.

The implementation is done inside the memory controller meaning RAIDR can not be adopted in currently existing systems. To minimize the storage needed for keeping track of bin members they use Bloom filters. Thanks to this, only 1.25 KB storage is needed for a 32 GB DRAM with the default configuration. The storage requirement can however vary depending the amount of bins used, but on the other hand the granularity of the approach becomes higher with more bins. 

RAIDR conform to temperature variations by utilizing a third counter that is used to scale all bins refresh rate with the temperature. Comparing RAIDR with the somewhat similar DTail-R Lie et al. does not achieve quite as big decrease in refresh operations as Cui et al. does. This is due to DTail-R having a higher granularity as the refresh rate is kept per row and not per row group as in RAIDR. Even so, a performance improvement of 4.1\% and a decrease in power consumption by 8.3\% is achieved in a system with 32GB DRAM compared to auto-refresh.