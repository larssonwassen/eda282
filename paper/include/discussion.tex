\section{Discussion} 
\label{sec:disc}

\todo[inline]{Drafty text below!}
\textbf{Broadly compare the techniques from different approaches}

\textbf{Advantages and disadvantages for each approach}
-What is modified? / Where is stuff stored?
-How much knowledge does the techniques have about the running software?
-Is the approach's benefits application-depended?
-PARIS could have used CBR if sREF was implemented (as Dtail does), but this extends DDRx instruction set...

Smart Refresh:
Employed its solution to 2 GB ram. What about todays sizes? How effective is the technique now? - Only works effective if large parts the memory is accessed, i.e. large part of the memory has to be valid to begin with. Is it so today?

Smart Refresh \& Refrint:
Refrint is somewhat a extension of Smart Refresh. Smart Refresh's features can be laid somewhat equal to Refrint's time-based polices, whereas the data-based polices have no equivalence in Smart Refresh.

They both modify the memory controller, and almost in the same way. But Refrint has no timers that is getting decremented the whole time, and instead copies a global `timer' to the line associated bits upon access. Of course Refrint's data-based polices also adds logic to the memory controller.

Discuss energy savings. Hard to do eDRAM vs DRAM...

\textbf{Which techniques can be combined?}

... any of these techniques can be combined with `scheduling real accesses together with refresh ops' (can them???). Mention CREAM as an example. 

Another proposed technique is ESKIMO by Isen and John \cite{eskimo}, which focus at reducing total DRAM power through optimizing the accesses to the DRAM. By using one bit of a cache row to denote whether it hold nonsense data, it becomes possible to resolve some memory accesses in the caches, which otherwise would have needed to access DRAM. A memory region is regarded as nonsense if it has been deallocated, or allocated but not written to. The ISA has to be extended to provide the allocation and deallocation information. If a block has to be replaced in a write-through cache and the replaced block is dirty but also deallocated, the cache can ignore writing the replaced block to memory. Similarly, a write miss to a newly allocated area results in a read access that can also be ignored. The latter optimization has support of a structure stored in DRAM which tracks nonsense rows. 

The 
Combining ESKIMO with the selective refresh implementation proposed by Oshawa \cite{oshawa} (ESKIMO[31]), $39\%$ of total DRAM power was saved on average.   

-Will any approach be benefited / dis-benefited by it?
-Which technique seems future proof?