
M. Ghosh and H.-H. S. Lee proposes the technique Smart Refresh \cite{smartrefresh} that targets Access Recency. The basic idea is to maintain a time-out counter for each memory row stored in the MC and these counters is set if the corresponding row is accessed. When a counter time-out, the MC issues a ROR refresh to the corresponding row and also sets the counter. 

The counters are decremented in such a fashion so the refreshes are distributed evenly over time. A higher bit size on the counters increases time granularity, which results in that a counter can be set later in time and thus postpones the refresh further. 

Can be deactivated

As mentioned, Smart Refresh modifies the MC. The memory footprint of the technique is 0.0024\% of total device capacity when 3-bits counters are used and assumptions , which is stored in the MC.

Results 




This scheme will be most effective if all lines are accessed before a refresh is needed. If no accesses are made = the entire working set fits into cache, Smart Refresh becomes CBR (CAS before RAS). Only refresh one line at a time = inefficient, so they have made it possible to turn the technique off.

Implemented so only one line per each logical segments are decremented at the same time, which leads to that the refreshes are evenly distributed over time. (I.e. no burst refresh.)

Overhead: 48KB for 2GB and 768 KB for 32GB = 0,0024\% overhead. 

Average reduction of refreshes by 59.3\% for 2GB and 52.3\% energy saving regarding the DRAM refresh. No performance degradation.

move:
Smart refresh:
Employed its solution to 2 GB ram. What about todays sizes? How effective is the technique now? - Only works effective if large parts the memory is acccessed, i.e. large part of the memory has to be valid to begin with. Is it so today?