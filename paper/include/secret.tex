With SECRET Lin et al. \cite{secret} masks cells with short retention time (bad cells) using Error Correction Pointers (ECP). The bad cells are mapped with a one time profiling done before first system use and all cells that do not meet the retention time requirements gets a ECP. A ECP is basically a pointer to another cell that is healthy. The framework, which is implemented inside the memory controller, checks whether there is any valid ECP for the address is accessed. If there is, it replaces the cell's data with the data from the cell pointed to by the ECP. The ECPs are stored in the DRAM during runtime and a cache in the memory controller is used to mask the delay of fetching the ECPs from DRAM.

The framework divides the DRAM into regions of typically \textit{128 KB}. For every one of these regions a \textit{Directory Entry} is kept. These directories holds the number of bad cells in the region and a address to where the ECPs are stored. As the Directory Entries need to be stored in a contiguous address space and the probability of that existing without any bad cell three copies are stored. A majority vote is then performed to mask any bit error in the Directory Entry. The size of each entry is $36\:b$ and all entries in a \textit{4 GB} system thus generates a total of $3 \times 36\:b \times \frac{4\:GB}{128\:KB} =$ \textit{432 KB} $= 0.010\%$ storage overhead. This is without the space needed for the actual ECPs which requires $21\:b$ each and the total space thereby varies with the number of bad cells.      

This approach gives a high energy saving of up to $87.2\%$ in refresh power and a reduction of $18.57\%$ in total DRAM power consumption with the ECP cache overhead taken into account and the refresh rate set to $512\:ms$ instead of the default $64\:ms$. The performance impact ranges from $1.3\%$ degradation at the worst to a $1.4\%$ improvement at the best. The degradation of performance is due to the added memory access needed to fetch the ECPs, and the performance improvement comes from the decreased congestion due to less refresh operations performed.