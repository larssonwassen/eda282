With SECRET Lin et al. \cite{secret} masks cells with short retention time (bad cells) using Error Correction Pointers (ECP). The DRAM cells are mapped through profiling, which is performed the first time the system is in use, and all bad cells are assigned an ECP. An ECP is basically a pointer to a cell that met the retention time requirements. The framework logic, which is implemented inside the MC, checks whether there is any ECP for the address accessed. If there is, it replaces the cell's data with the data from the cell pointed to by the ECP. The ECPs are stored in DRAM during runtime and are also cached in the MC to mask the delay of fetching them from DRAM.

The framework divides the DRAM into regions of typically \textit{128 KB}. For every region a \textit{Directory Entry} is kept. These directories holds the number of bad cells in a region and an address to where the ECPs are stored. As the Directory Entries need to be stored in a contiguous address space and the probability of that existing without any bad cell, three copies are stored. A majority vote is then performed to mask any bit error in the Directory Entries. The size of each entry is $36\:b$ and all entries in a \textit{4 GB} system thus generates a total of $3 \times 36\:b \times \frac{4\:GB}{128\:KB} =$ \textit{432 KB} $= 0.010\%$ storage overhead. This is without the space needed for the actual ECPs which requires $21\:b$ each and the total space thereby varies with the number of bad cells. 

This technique saves up to $87.2\%$ of refresh power consumption which corresponds to a total reduction of DRAM power consumption of $18.6\%$, when the ECP cache overhead is taken into account and the refresh rate set to $512\:ms$ instead of the default $64\:ms$. The performance impact ranges from $1.3\%$ degradation at the worst to a $1.4\%$ improvement at the best. The degradation is due to the added memory accesses needed to fetch the ECPs, and the  improvement comes from the decreased DRAM access congestion due to less refresh operations performed.