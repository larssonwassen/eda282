RIO is a Retention Time based technique proposed by Baek et al. \cite{rioparis} in which low retention time cells (bad cells) are identified and `deleted'. This is performed by changing the memory allocating modules in the OS to not allocate pages that have bad cells in them. Beak et al. implement RIO in a Linux kernel which is run and tested on a real hardware system and achieves $87.5\%$ reduction in refresh count with a performance increase of $4.5\%$ on average. It was found that aiming for a refresh period longer than $256~ms$ only yields a small performance and power improvement and therefore is the refresh period set to that. The implementation mostly relies on modifications to the kernel and there is no need to modify the hardware, so the technique would be easy to adopt in systems today. 

To keep fragmentation of the memory low, a maximum of $0.1\%$ of total memory pages gets `deleted'. Even though deletion of a larger amount of pages could decrease the amount of refreshes further it would cause trouble for the kernel which relies on being able to allocate large contiguous address spaces. It would also cause a bigger loss of memory available to the system. As retention time varies hugely with temperature, RIO continuously measures the system temperature and compensate the refresh periods for it. 

Baek et al. also propose PARIS \cite{rioparis}, which can be combined with RIO for further improvements. In PARIS, the goal is to avoid refreshing unused rows by using Validity information instead of prolonging the refresh rate. This is performed by keeping track of all page frames allocated and deallocated by the Linux kernel. The page frame data is translated to DRAM row data and kept in a bitmap with one full/empty bit per group of rows. A group of rows consist of any number of consecutive global rows. Larger groups give a smaller storage overhead for the bitmap, but lowers the refresh granularity. The bitmap is stored in the MC and the storage overhead is $0.0015\%$ in a system with a \textit{8 KB} row size and one row per group. The method used for refresh is ROR. 

As mentioned earlier, RIO and PARIS can be combined, which results in PARIS removing unnecessary refreshes and RIO lowering the rate at which the performed refreshes are done. This is similar to what Cui et al. does with DTail-RV. Cui et al. manages to lower the number of refreshes somewhat more than Baek et al. does with RIO and PARIS. The difference comes from DTail-V performing better than PARIS due to DTail keeping Validity information per row instead of per group of rows. RIO and DTail-R performs similar but RIO have a bigger storage overhead. DTail requires changes to the MC while RIO and PARIS is implemented in software and thus are more easy to realize. 